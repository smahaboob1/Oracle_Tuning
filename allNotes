1. Query execution should not start with join operation
2. Create Index on the column which has max number of distinct rows (close to total records in the table)
3. Create Index on the column that has '=' operator in SQL (< or > will return multiple records)
4. Runnning Sub Query first (if EXISTS is not used)

5. Case Study 4: Whenever there is a join operation, 
we have to make sure that the join condition columns used for both the tables should be a primary/unique key 
or should have too many distinct values.

6. Case Study 5: There is a hash join operation between the Employees and Departments table. 
Employees table is qualifying for only 11 rows and since Department_id is a primary key in DEPARTMENTS table, 
the join operation should also result in 11 rows. 
However, in this case there is a hash join operation between employees and departments table causing additional time.

7. Case Study 6: Whenever there is a exist operator, we have to make sure that the subquery within the exist operator is not accessed 
or executed first. This will result in passing each table row from the outer table inside the exist operator 
and validate the exist condition. The bigger the size of the outer table, more time it is going to take.

8. Case Study 7: Whenever there is a column present in the where part of the clause multiple time for a specific table, 
EMPLOYEE_ID in this case, then such a table should be accessed based on the condition which is going to expect 
the least number of rows. In this case, EMPLOYEE_ID IN ( 100,101,102,103,104,105 ) is expecting only 6 rows where as 
EMPLOYEE_ID > 0 is going to access the entire table. 
Hence, in this case the EMPLOYEES table should be accessed using EMPLOYEE_ID IN ( 100,101,102,103,104,105 ).




